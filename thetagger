#!/usr/bin/env python
"""
./albumimporter 
"""

import os
import re
import shutil
import subprocess
import sys
import tempfile

# monkeypatch eyeD3
import eyeD3

def getAlbumArtist(self):
   f = self.frames['TPE2'];
   if f:
      return f[0].text;
   else:
      return u"";
eyeD3.Tag.getAlbumArtist = getAlbumArtist

def _set(self, data, frameHeader):
  eyeD3.frames.TextFrame._set(self, data, frameHeader);
  if self.header.id[:2] != "TD" and self.header.minorVersion >= 4:
    print "[warning]: Invalid frame id for DateFrame: %s" % self.header.id
eyeD3.frames.DateFrame._set = _set

class MP3(object):
  def __init__(self, input_file):
    self.input_file = input_file
    if not eyeD3.isMp3File(input_file):
      raise RuntimeError("eyeD3 can not parse %s" % input_file)

    self.audio_file = eyeD3.Mp3AudioFile(input_file)
    self.tag        = self.audio_file.getTag()

    self.album_artist = self.tag.getAlbumArtist()
    self.album        = self.tag.getAlbum()
    self.year         = self.tag.getYear()
    self.disc_num     = self.tag.getDiscNum()[0]
    self.disc_total   = self.tag.getDiscNum()[1]
    self.track_num    = self.tag.getTrackNum()[0]
    self.track_total  = self.tag.getTrackNum()[1]
    self.artist       = self.tag.getArtist()
    self.title        = self.tag.getTitle()
    self.genre        = self.tag.getGenre() and self.tag.getGenre().name or None

  def __repr__(self):
    return u"<MP3 %s>" % self.__unicode__()

  def __unicode__(self):
    return u"%s - %s - %s.mp3" % (self.track_num, self.artist, self.title)

class JPG(object):
  def __init__(self, input_file):
    self.input_file = input_file

class Album(object):
  def __init__(self, input_dir, options):
    self.input_dir  = self.verify_dir(input_dir)
    self.output_dir = self.verify_dir(options.output_dir)

    if options.mode == 'preview':
      self.pre_preview()

    self.mp3s = [MP3(f) for f in self.glob('.mp3')]
    self.jpgs = [JPG(f) for f in self.glob('.jpg')]

    self.album_artist = self.guess_album_artist()
    self.album        = self.guess_album()
    self.year         = self.guess_year()
    self.track_total  = self.guess_track_total()
    self.disc_total   = self.guess_disc_total()

    self.preview()

  def pre_preview(self):
    print "##########"
    print "## %s" % self.input_dir

  def preview(self):
    for mp3 in self.mp3s:
      print "%s - %s - %s/%s" % (self.album_artist, self.album, self.year, mp3)
    print "%s disc(s), %s tracks" % (self.disc_total, self.track_total)

  def verify_dir(self, d):
    d = os.path.normpath(d)
    d = os.path.expanduser(d)
    if not os.path.isdir(d):
      raise RuntimeError("directory '%s' does not exist." % d)
    return d

  def glob(self, ext):
    matches = []
    for root, sud_dirs, files in os.walk(self.input_dir):
      for file in files:
        if os.path.splitext(file)[1] == ext:
          matches.append(os.path.join(root,file))
    return matches

  def guess_album_artist(self):
    album_artist = self.uniform('album_artist') or self.uniform('artist')
    return album_artist

  def guess_album(self):
    return self.uniform('album')

  def guess_year(self):
    return self.uniform('year')

  def guess_track_total(self):
    return self.uniform('track_total') or len(self.mp3s)

  def guess_disc_total(self):
    return self.uniform('disc_total') or 1

  def uniform(self, attr):
    values = list(set([getattr(mp3, attr) for mp3 in self.mp3s]))
    if len(values) == 1 and values[0] != u'':
      return values[0]
    return None

if __name__ == "__main__":
  from optparse import OptionParser, OptionGroup
  parser = OptionParser(usage="usage: %prog [options] input_album_dir")

  group = OptionGroup(parser, "Metadata Options")
  group.add_option("--album-artist", default=None, help="Album Artist")
  parser.add_option_group(group)

  group = OptionGroup(parser, "File Options")  
  group.add_option("-o", "--output-dir", default=".", help="Output directory. Default is '.'")
  group.add_option("-m", "--mode", default="preview", help="'preview' or 'copy' action. Default is 'preview'")
  parser.add_option_group(group)

  options, args = parser.parse_args()
  if len(args) < 1:
    parser.print_help()
    sys.exit(1)

  try:
    for d in args:
      r = Album(d, options)
    sys.exit(0)
  except RuntimeError, e:
    print "\nERRORS: %s" % e
    sys.exit(1)