#!/usr/bin/env python
"""
./albumimporter 
"""

import os
import re
import shutil
import subprocess
import sys
import tempfile

from titlecase import titlecase

# monkeypatch eyeD3
import eyeD3

def getAlbumArtist(self):
   f = self.frames['TPE2'];
   if f:
      return f[0].text;
   else:
      return u"";
eyeD3.Tag.getAlbumArtist = getAlbumArtist

def setAlbumArtist(self, a):
   self.setTextFrame('TPE2', self.strToUnicode(a));
eyeD3.Tag.setAlbumArtist = setAlbumArtist

def _set(self, data, frameHeader):
  eyeD3.frames.TextFrame._set(self, data, frameHeader);
  if self.header.id[:2] != "TD" and self.header.minorVersion >= 4:
    print "[warning]: Invalid frame id for DateFrame: %s" % self.header.id
eyeD3.frames.DateFrame._set = _set

class MP3(object):
  def __init__(self, input_file, writable=False):
    self.input_file = input_file
    self.writable   = writable
    if not eyeD3.isMp3File(input_file):
      raise RuntimeError("eyeD3 can not parse %s" % input_file)

    self.audio_file = eyeD3.Mp3AudioFile(input_file)
    self.tag        = self.audio_file.getTag()

    self.album_artist = self.tag.getAlbumArtist()
    self.album        = self.tag.getAlbum()
    self.year         = self.tag.getYear()
    self.disc_num     = self.tag.getDiscNum()[0]
    self.disc_total   = self.tag.getDiscNum()[1]
    self.track_num    = self.tag.getTrackNum()[0]
    self.track_total  = self.tag.getTrackNum()[1]
    self.artist       = self.tag.getArtist()
    self.title        = self.tag.getTitle()
    self.genre        = self.tag.getGenre() and self.tag.getGenre().name or None

  def __repr__(self):
    return u"<MP3 %s>" % self.__unicode__()

  def __unicode__(self, titlecase=None):
    return u"%s - %s - %s.mp3" % (self.track_num, self.artist, self.title)

  def update(self, metadata):
    if not self.writable:
      raise RuntimeError("%s was not set as writable" % self.input_file)

    print metadata
    self.tag.remove()
    self.tag.setAlbumArtist(metadata["album_artist"])
    self.tag.setAlbum(metadata["album"])
    self.tag.setDate(metadata["year"])
    self.tag.setDiscNum((metadata["disc_num"], metadata["disc_total"]))
    self.tag.setTrackNum((metadata["track_num"], metadata["track_total"]))
    self.tag.setArtist(metadata["artist"])
    self.tag.setTitle(metadata["title"])
    self.tag.setGenre(metadata["genre"])
    self.tag.update(eyeD3.ID3_V2_4)
    #self.tag.update(eyeD3.ID3_V1_1 | eyeD3.ID3_V2_4)

class JPG(object):
  def __init__(self, input_file):
    self.input_file = input_file

class Album(object):
  def __init__(self, input_dir, options):
    self.input_dir  = self.verify_dir(input_dir)
    self.output_dir = self.verify_dir(options.output_dir)

    if options.mode == 'preview':
      self.pre_preview()

    self.mp3s = [MP3(f) for f in self.glob('.mp3')]
    self.jpgs = [JPG(f) for f in self.glob('.jpg')]

    self.album_artist = self.guess_album_artist()
    self.album        = self.guess_album()
    self.year         = self.guess_year()
    self.tracks       = self.guess_tracks()

    if options.mode == 'preview':
      self.preview()
    elif options.mode == 'copy':
      self.copy()

  def pre_preview(self):
    print "##########"
    print "## %s" % self.input_dir
    print "##########"

  def preview(self):
    width = 0
    for track in self.tracks:
      path = "%s/%s" % (track['output_dir'], track['output_file'])
      if len(path) > width:
        width = len(path)

    for track in self.tracks:
      path = "%s/%s" % (track['output_dir'], track['output_file'])
      path = path.ljust(width)
      print "%s [%02d/%02d, %02d/%02d, %s]" % (path, track['disc_num'], track['disc_total'], track['track_num'], track['track_total'], track['genre'])
    print ""

  def copy(self):
    # create a clean temp temp_dir
    temp_dir = "/tmp/%s" % self.tracks[0]['output_dir']
    try:
      shutil.rmtree(temp_dir)
    except OSError, e:
      pass
    os.mkdir(temp_dir)

    # copy files over to temp_dir
    for track in self.tracks:
      temp_file = os.path.join(temp_dir, track['output_file'])
      shutil.copy(track['mp3'].input_file, temp_file)
      temp_mp3 = MP3(temp_file, writable=True)
      temp_mp3.update(track)

    # move the tempdir to destdir
    # copy the entire directory to a tempdir
    
    pass

  def verify_dir(self, d):
    d = os.path.normpath(d)
    d = os.path.expanduser(d)
    if not os.path.isdir(d):
      raise RuntimeError("directory '%s' does not exist." % d)
    return d

  def glob(self, ext):
    matches = []
    for root, sud_dirs, files in os.walk(self.input_dir):
      for file in files:
        if os.path.splitext(file)[1] == ext:
          matches.append(os.path.join(root,file))
    return matches

  def guess_album_artist(self):
    album_artist = self.uniform('album_artist') or self.uniform('artist')
    return album_artist

  def guess_album(self):
    return self.uniform('album')

  def guess_year(self):
    return self.uniform('year')

  def uniform(self, attr):
    values = list(set([getattr(mp3, attr) for mp3 in self.mp3s]))
    if len(values) == 1 and values[0] != u'':
      return values[0]
    return None

  def guess_tracks(self):
    """
    Collect the _desired_ metadata for the entire album.
    """
    # first pass validates track/disk nums
    tracks = []
    dtns = {}
    disc_track_totals = {}

    # assume a sorted set that can be assigned an increasing disc_num
    disc_total = 1
    unsorted = False

    for mp3 in self.mp3s:
      track = {}
      track['mp3'] = mp3

      if not mp3.track_num:
        raise RuntimeError("No track num present")

      track['disc_num'] = mp3.disc_num or disc_total
      track['disc_track_num'] = "%02d%02d" % (track['disc_num'], mp3.track_num)
      if track['disc_track_num'] not in dtns:
        dtns[track['disc_track_num']] = 1
      else:
        if unsorted:
          raise RuntimeError("No disc num present for un-sorted multi-disc set? (%s dupe)" % track['disc_track_num'])
        else:
          disc_total += 1
          track['disc_num'] = mp3.disc_num or disc_total
          track['disc_track_num'] = "%02d%02d" % (track['disc_num'], mp3.track_num)

      if disc_total not in disc_track_totals:
        disc_track_totals[disc_total] = 1
      else:
        disc_track_totals[disc_total] += 1

      # insert into list sorted by disc_track_num
      if len(tracks) == 0:
        tracks.append(track)
        continue

      if tracks[len(tracks)-1]['disc_track_num'] < track['disc_track_num']:
        tracks.append(track)
      else:
        unsorted = True
        i = 0
        t = tracks[i]
        while t['disc_track_num'] < track['disc_track_num']:
          i += 1
          if i >= len(tracks):
            break
          t = tracks[i]
        tracks.insert(i, track)

    for track in tracks:
      mp3 = track['mp3']
      track['album_artist'] = titlecase(self.album_artist).strip()
      track['album']        = titlecase(self.album).strip()
      track['year']         = self.year
      track['artist']       = titlecase(mp3.artist).strip()
      track['title']        = titlecase(mp3.title).strip()
      track['genre']        = mp3.genre

      # disc/track nums were calculated in validation pass
      track['disc_total']   = disc_total
      track['disc_num']     = track['disc_num']
      track['track_num']    = mp3.track_num
      track['track_total']  = disc_track_totals[track['disc_num']]
      track['disc_track_num'] = "%02d" % track['track_num']
      if disc_total > 1:
        track['disc_track_num'] = "%d%02d" % (track['disc_num'], track['track_num'])

      track['output_dir']   = "%s - %s (%s)"    % (track['album_artist'], track['album'], track['year'])
      track['output_dir']   = track['output_dir'].replace('/', '_')
      track['output_file']  = "%s - %s - %s.mp3"  % (track['disc_track_num'], track['artist'], track['title'])
      track['output_file']  = track['output_file'].replace('/', '_')

    return tracks

if __name__ == "__main__":
  from optparse import OptionParser, OptionGroup
  parser = OptionParser(usage="usage: %prog [options] input_album_dir")

  group = OptionGroup(parser, "Metadata Options")
  group.add_option("--title-case", default=None, help="Apply Title Case to Fields?")
  group.add_option("--album-artist", default=None, help="Album Artist")
  group.add_option("--genre", default=None, help="Genre")
  parser.add_option_group(group)

  group = OptionGroup(parser, "File Options")  
  group.add_option("-o", "--output-dir", default=".", help="Output directory. Default is '.'")
  group.add_option("-m", "--mode", default="preview", help="'preview' or 'copy' action. Default is 'preview'")
  parser.add_option_group(group)

  options, args = parser.parse_args()
  if len(args) < 1:
    parser.print_help()
    sys.exit(1)

  try:
    for d in args:
      r = Album(d, options)
    sys.exit(0)
  except RuntimeError, e:
    print "ERRORS: %s" % e
    sys.exit(1)